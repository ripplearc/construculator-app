<?xml version="1.0" encoding="UTF-8"?>
<mutations version="1.0">
    <!-- COST ESTIMATION REPOSITORY IMPLEMENTATION MUTATION TESTING -->
    <!-- Targets: Repository implementation for cost estimations -->

    <files>
        <file>lib/features/estimation/data/repositories/cost_estimation_repository_impl.dart</file>
    </files>

    <exclude>
        <!-- Exclude logging statements -->
        <regex pattern="_logger\.(debug|info|warning|error)\s*\(" dotAll="false"/>

        <!-- Exclude try-catch structure -->
        <regex pattern="try\s*{" dotAll="false"/>
        <regex pattern="catch\s*\(" dotAll="false"/>

        <!-- Exclude override annotations -->
        <regex pattern="@override" dotAll="false"/>
    </exclude>

    <rules>
        <!-- RULE 1: In fetchInitialEstimations, wrong offset value -->
        <regex pattern="offset: 0," dotAll="true" id="repo.pagination.wrong_initial_offset">
            <mutation text="offset: 10,"/>
        </regex>

        <!-- RULE 2: In fetchInitialEstimations, invert hasMore calculation -->
        <regex pattern="final hasMore = costEstimates\.length >= defaultPageSize;" dotAll="true" id="repo.pagination.invert_hasmore">
            <mutation text="final hasMore = costEstimates.length &lt; defaultPageSize;"/>
        </regex>

        <!-- RULE 3: In loadMoreEstimations, skip hasMore guard check -->
        <regex pattern="if \(!paginationState\.hasMore\) \{" dotAll="true" id="repo.pagination.skip_hasmore_check">
            <mutation text="if (paginationState.hasMore) {"/>
        </regex>

        <!-- RULE 4: In loadMoreEstimations, use wrong offset -->
        <regex pattern="offset: paginationState\.currentOffset," dotAll="true" id="repo.pagination.wrong_offset">
            <mutation text="offset: 0,"/>
        </regex>

        <!-- RULE 5: In loadMoreEstimations, don't append new data to existing -->
        <regex pattern="final allEstimates = \[\.\.\.existingEstimates, \.\.\.newEstimates\];" dotAll="true" id="repo.data.skip_append">
            <mutation text="final allEstimates = newEstimates;"/>
        </regex>

        <!-- RULE 6: In loadMoreEstimations, use wrong offset calculation -->
        <regex pattern="currentOffset: allEstimates\.length," dotAll="true" id="repo.pagination.wrong_offset_calculation">
            <mutation text="currentOffset: newEstimates.length,"/>
        </regex>

        <!-- RULE 7: In hasMoreEstimations, return wrong default value -->
        <regex pattern="return _paginationStates\[projectId\]\?\.hasMore \?\? true;" dotAll="true" id="repo.pagination.wrong_default_hasmore">
            <mutation text="return _paginationStates[projectId]?.hasMore ?? false;"/>
        </regex>

        <!-- RULE 8: In _emitToStream, skip emitting to stream -->
        <regex pattern="_streamControllers\[projectId\]\?\.add\(result\);" dotAll="true" id="repo.stream.skip_emit">
            <mutation text="// _streamControllers[projectId]?.add(result);"/>
        </regex>

        <!-- RULE 9: In _updateStreamWithNewEstimation, fail to increment offset -->
        <regex pattern="currentOffset: paginationState\.currentOffset \+ 1," dotAll="true" id="repo.pagination.skip_increment">
            <mutation text="currentOffset: paginationState.currentOffset,"/>
        </regex>

        <!-- RULE 10: In _updateStreamWithNewEstimation, add to end instead of beginning -->
        <regex pattern="final updatedEstimations = \[newEstimation, \.\.\.cachedEstimations\];" dotAll="true" id="repo.data.wrong_insert_position">
            <mutation text="final updatedEstimations = [...cachedEstimations, newEstimation];"/>
        </regex>

        <!-- RULE 11: In _updateStreamWithDeletedEstimation, fail to decrement offset -->
        <regex pattern="currentOffset: \(paginationState\.currentOffset - 1\)\.clamp\(" dotAll="true" id="repo.pagination.skip_decrement">
            <mutation text="currentOffset: paginationState.currentOffset.clamp("/>
        </regex>

        <!-- RULE 12: Skip emitting to stream on success -->
        <regex pattern="_emitToStream\(projectId, Right\(costEstimates\)\);" dotAll="true" id="repo.stream.skip_emit_success">
            <mutation text="// _emitToStream(projectId, Right(costEstimates));"/>
        </regex>

        <!-- RULE 13: Skip emitting to stream on error -->
        <regex pattern="_emitToStream\(projectId, Left\(failure\)\);" dotAll="true" id="repo.stream.skip_emit_error">
            <mutation text="// _emitToStream(projectId, Left(failure));"/>
        </regex>

        <!-- RULE 14: In deleteEstimation, skip updating stream before delete -->
        <regex pattern="_updateStreamWithDeletedEstimation\(projectId, estimationId\);" dotAll="true" id="repo.delete.skip_stream_update">
            <mutation text="// _updateStreamWithDeletedEstimation(projectId, estimationId);"/>
        </regex>

        <!-- RULE 15: In deleteEstimation, skip refetch on error -->
        <regex pattern="await fetchInitialEstimations\(projectId\);" dotAll="true" id="repo.delete.skip_refetch_on_error">
            <mutation text="// await fetchInitialEstimations(projectId);"/>
        </regex>

        <!-- RULE 16: In changeLockStatus, skip optimistic update -->
        <regex pattern="_emitOptimisticUpdate\(\s*projectId: projectId,\s*estimationId: estimationId,\s*updateFn: \(e\) =&gt; e\.copyWith\(\s*lockStatus: isLocked \? LockStatus\.locked\(\) : LockStatus\.unlocked\(\),\s*\),\s*\);" dotAll="true" id="repo.lock.skip_optimistic_update">
            <mutation text="// _emitOptimisticUpdate(projectId: projectId, estimationId: estimationId, updateFn: (e) => e.copyWith(lockStatus: isLocked ? LockStatus.locked() : LockStatus.unlocked()));"/>
        </regex>

        <!-- RULE 17: In changeLockStatus, skip final stream update -->
        <regex pattern="_updateStreamWithEstimation\(projectId, estimationId, updatedEstimation\);" dotAll="true" id="repo.lock.skip_final_update">
            <mutation text="// _updateStreamWithEstimation(projectId, estimationId, updatedEstimation);"/>
        </regex>

        <!-- RULE 18: In changeLockStatus, skip rollback on error -->
        <regex pattern="_rollbackOptimisticUpdate\(projectId, estimationId, originalEstimation\);" dotAll="true" id="repo.lock.skip_rollback">
            <mutation text="// _rollbackOptimisticUpdate(projectId, estimationId, originalEstimation);"/>
        </regex>

        <!-- RULE 19: In _emitOptimisticUpdate, update all estimations instead of target -->
        <regex pattern="return e\.id == estimationId\s*\? updateFn\(e\)\s*: e;" dotAll="true" id="repo.optimistic.update_all">
            <mutation text="return updateFn(e);"/>
        </regex>

        <!-- RULE 20: In _updateStreamWithEstimation, update all estimations instead of target -->
        <regex pattern="return e\.id == estimationId \? updatedEstimation : e;" dotAll="true" id="repo.stream.update_all_final">
            <mutation text="return updatedEstimation;"/>
        </regex>

        <!-- RULE 21: In _rollbackOptimisticUpdate, update all estimations instead of target -->
        <regex pattern="return e\.id == estimationId\s*\? originalEstimation\s*: e;" dotAll="true" id="repo.rollback.update_all">
            <mutation text="return originalEstimation;"/>
        </regex>

        <!-- RULE 22: In _emitOptimisticUpdate, skip stream emission -->
        <regex pattern="_emitToStream\(projectId, Right\(updatedList\)\);" dotAll="true" id="repo.lock.skip_optimistic_emission">
            <mutation text="// _emitToStream(projectId, Right(updatedList));"/>
        </regex>

        <!-- RULE 23: In _getOriginalEstimation, always return null -->
        <regex pattern="if \(!_streamControllers\.containsKey\(projectId\)\) \{\s*return null;\s*\}" dotAll="true" id="repo.get_original.always_null">
            <mutation text="return null;"/>
        </regex>

        <!-- RULE 24: In changeLockStatus, invert lock status in optimistic update -->
        <regex pattern="lockStatus: isLocked \? LockStatus\.locked\(\) : LockStatus\.unlocked\(\)" dotAll="true" id="repo.lock.invert_optimistic_status">
            <mutation text="lockStatus: !isLocked ? LockStatus.locked() : LockStatus.unlocked()"/>
        </regex>

        <!-- RULE 25: In renameEstimation, skip optimistic update -->
        <regex pattern="_emitOptimisticUpdate\(\s*projectId: projectId,\s*estimationId: estimationId,\s*updateFn: \(e\) =&gt; e\.copyWith\(estimateName: newName\),\s*\);" dotAll="true" id="repo.rename.skip_optimistic_update">
            <mutation text="// _emitOptimisticUpdate(projectId: projectId, estimationId: estimationId, updateFn: (e) => e.copyWith(estimateName: newName));"/>
        </regex>

        <!-- RULE 26: In renameEstimation, skip final stream update -->
        <regex pattern="_updateStreamWithEstimation\(projectId, estimationId, updatedEstimation\);" dotAll="true" id="repo.rename.skip_final_update">
            <mutation text="// _updateStreamWithEstimation(projectId, estimationId, updatedEstimation);"/>
        </regex>

        <!-- RULE 27: In renameEstimation, skip rollback on error -->
        <regex pattern="_rollbackOptimisticUpdate\(projectId, estimationId, originalEstimation\);" dotAll="true" id="repo.rename.skip_rollback">
            <mutation text="// _rollbackOptimisticUpdate(projectId, estimationId, originalEstimation);"/>
        </regex>

        <!-- RULE 28: In renameEstimation, use empty string instead of newName -->
        <regex pattern="updateFn: \(e\) =&gt; e\.copyWith\(estimateName: newName\)" dotAll="true" id="repo.rename.empty_name">
            <mutation text="updateFn: (e) => e.copyWith(estimateName: '')"/>
        </regex>

        <!-- RULE 29: In renameEstimation, use wrong field in optimistic update -->
        <regex pattern="e\.copyWith\(estimateName: newName\)" dotAll="true" id="repo.rename.wrong_field">
            <mutation text="e.copyWith(estimateDescription: newName)"/>
        </regex>
    </rules>

    <commands>
        <command group="cost_estimation_repository" expected-return="0">flutter test test/features/estimations/units/data/repositories/cost_estimation_repository_impl_test.dart</command>
    </commands>

    <threshold failure="85">
        <rating over="85" name="A"/>
        <rating over="75" name="B"/>
        <rating over="65" name="C"/>
        <rating over="55" name="D"/>
        <rating over="35" name="E"/>
        <rating over="0" name="F"/>
    </threshold>
</mutations>
